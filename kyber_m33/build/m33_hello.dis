
build/m33_hello.elf:     file format elf32-littlearm


Disassembly of section .vectors:

00000000 <__isr_vector>:
   0:	20010000 	.word	0x20010000
   4:	00000d21 	.word	0x00000d21
   8:	00000dd1 	.word	0x00000dd1
   c:	00000dd3 	.word	0x00000dd3
  10:	00000dd5 	.word	0x00000dd5
  14:	00000dd7 	.word	0x00000dd7
  18:	00000dd9 	.word	0x00000dd9
  1c:	00000ddb 	.word	0x00000ddb
	...
  2c:	00000ddd 	.word	0x00000ddd
  30:	00000ddf 	.word	0x00000ddf
  34:	00000000 	.word	0x00000000
  38:	00000de1 	.word	0x00000de1
  3c:	00000de3 	.word	0x00000de3
	...
  b0:	00000de5 	.word	0x00000de5
  b4:	00000de5 	.word	0x00000de5
  b8:	00000de5 	.word	0x00000de5
  bc:	00000de5 	.word	0x00000de5
	...
 140:	00000de5 	.word	0x00000de5
 144:	00000de5 	.word	0x00000de5
	...
 158:	00000de5 	.word	0x00000de5
 15c:	00000de5 	.word	0x00000de5
 160:	00000de5 	.word	0x00000de5
 164:	00000000 	.word	0x00000000
 168:	00000de5 	.word	0x00000de5
 16c:	00000de5 	.word	0x00000de5
 170:	00000de5 	.word	0x00000de5
	...
 188:	00000de5 	.word	0x00000de5
 18c:	00000000 	.word	0x00000000
 190:	00000de5 	.word	0x00000de5
 194:	00000de5 	.word	0x00000de5
	...
 1a0:	00000de5 	.word	0x00000de5
	...
 240:	00000de5 	.word	0x00000de5
	...
 254:	00000de5 	.word	0x00000de5
 258:	00000000 	.word	0x00000000
 25c:	00000de5 	.word	0x00000de5
 260:	00000de5 	.word	0x00000de5
 264:	00000de5 	.word	0x00000de5
 268:	00000de5 	.word	0x00000de5
 26c:	00000de5 	.word	0x00000de5
	...
 340:	00000de5 	.word	0x00000de5
	...
 358:	00000de5 	.word	0x00000de5
 35c:	00000de5 	.word	0x00000de5
 360:	00000de5 	.word	0x00000de5
 364:	00000de5 	.word	0x00000de5
 368:	00000de5 	.word	0x00000de5
 36c:	00000de5 	.word	0x00000de5
 370:	00000de5 	.word	0x00000de5
 374:	00000de5 	.word	0x00000de5
 378:	00000de5 	.word	0x00000de5
 37c:	00000000 	.word	0x00000000
 380:	00000de5 	.word	0x00000de5
 384:	00000de5 	.word	0x00000de5
 388:	00000de5 	.word	0x00000de5
 38c:	00000de5 	.word	0x00000de5
 390:	00000de5 	.word	0x00000de5
 394:	00000de5 	.word	0x00000de5
 398:	00000de5 	.word	0x00000de5
 39c:	00000de5 	.word	0x00000de5
	...
 3a8:	00000de5 	.word	0x00000de5
 3ac:	00000de5 	.word	0x00000de5
 3b0:	00000de5 	.word	0x00000de5
 3b4:	00000de5 	.word	0x00000de5
	...
 3c0:	00000de5 	.word	0x00000de5
 3c4:	00000de5 	.word	0x00000de5
 3c8:	00000de5 	.word	0x00000de5
 3cc:	00000de5 	.word	0x00000de5
 3d0:	00000de5 	.word	0x00000de5
 3d4:	00000de5 	.word	0x00000de5
	...
 440:	00000de5 	.word	0x00000de5
	...
 450:	00000de5 	.word	0x00000de5
 454:	00000de5 	.word	0x00000de5
 458:	00000de5 	.word	0x00000de5
 45c:	00000000 	.word	0x00000000
 460:	00000de5 	.word	0x00000de5
 464:	00000de5 	.word	0x00000de5
	...
 470:	00000de5 	.word	0x00000de5
 474:	00000de5 	.word	0x00000de5

Disassembly of section .text:

00000490 <deregister_tm_clones>:
 490:	4803      	ldr	r0, [pc, #12]	@ (4a0 <deregister_tm_clones+0x10>)
 492:	4b04      	ldr	r3, [pc, #16]	@ (4a4 <deregister_tm_clones+0x14>)
 494:	4283      	cmp	r3, r0
 496:	d002      	beq.n	49e <deregister_tm_clones+0xe>
 498:	4b03      	ldr	r3, [pc, #12]	@ (4a8 <deregister_tm_clones+0x18>)
 49a:	b103      	cbz	r3, 49e <deregister_tm_clones+0xe>
 49c:	4718      	bx	r3
 49e:	4770      	bx	lr
 4a0:	20000004 	.word	0x20000004
 4a4:	20000004 	.word	0x20000004
 4a8:	00000000 	.word	0x00000000

000004ac <register_tm_clones>:
 4ac:	4b06      	ldr	r3, [pc, #24]	@ (4c8 <register_tm_clones+0x1c>)
 4ae:	4907      	ldr	r1, [pc, #28]	@ (4cc <register_tm_clones+0x20>)
 4b0:	1ac9      	subs	r1, r1, r3
 4b2:	1089      	asrs	r1, r1, #2
 4b4:	bf48      	it	mi
 4b6:	3101      	addmi	r1, #1
 4b8:	1049      	asrs	r1, r1, #1
 4ba:	d003      	beq.n	4c4 <register_tm_clones+0x18>
 4bc:	4b04      	ldr	r3, [pc, #16]	@ (4d0 <register_tm_clones+0x24>)
 4be:	b10b      	cbz	r3, 4c4 <register_tm_clones+0x18>
 4c0:	4801      	ldr	r0, [pc, #4]	@ (4c8 <register_tm_clones+0x1c>)
 4c2:	4718      	bx	r3
 4c4:	4770      	bx	lr
 4c6:	bf00      	nop
 4c8:	20000004 	.word	0x20000004
 4cc:	20000004 	.word	0x20000004
 4d0:	00000000 	.word	0x00000000

000004d4 <__do_global_dtors_aux>:
 4d4:	b510      	push	{r4, lr}
 4d6:	4c06      	ldr	r4, [pc, #24]	@ (4f0 <__do_global_dtors_aux+0x1c>)
 4d8:	7823      	ldrb	r3, [r4, #0]
 4da:	b943      	cbnz	r3, 4ee <__do_global_dtors_aux+0x1a>
 4dc:	f7ff ffd8 	bl	490 <deregister_tm_clones>
 4e0:	4b04      	ldr	r3, [pc, #16]	@ (4f4 <__do_global_dtors_aux+0x20>)
 4e2:	b113      	cbz	r3, 4ea <__do_global_dtors_aux+0x16>
 4e4:	4804      	ldr	r0, [pc, #16]	@ (4f8 <__do_global_dtors_aux+0x24>)
 4e6:	f3af 8000 	nop.w
 4ea:	2301      	movs	r3, #1
 4ec:	7023      	strb	r3, [r4, #0]
 4ee:	bd10      	pop	{r4, pc}
 4f0:	20000004 	.word	0x20000004
 4f4:	00000000 	.word	0x00000000
 4f8:	00000e08 	.word	0x00000e08

000004fc <frame_dummy>:
 4fc:	b508      	push	{r3, lr}
 4fe:	4b04      	ldr	r3, [pc, #16]	@ (510 <frame_dummy+0x14>)
 500:	b11b      	cbz	r3, 50a <frame_dummy+0xe>
 502:	4904      	ldr	r1, [pc, #16]	@ (514 <frame_dummy+0x18>)
 504:	4804      	ldr	r0, [pc, #16]	@ (518 <frame_dummy+0x1c>)
 506:	f3af 8000 	nop.w
 50a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 50e:	e7cd      	b.n	4ac <register_tm_clones>
 510:	00000000 	.word	0x00000000
 514:	20000008 	.word	0x20000008
 518:	00000e08 	.word	0x00000e08

0000051c <main>:
#include <stdio.h>
#include <nrf.h>

void main(void) {
 51c:	b508      	push	{r3, lr}

  printf("hello world\n");
 51e:	4802      	ldr	r0, [pc, #8]	@ (528 <main+0xc>)
 520:	f000 fb9e 	bl	c60 <printf>
  while(1) {
    asm volatile("wfi");
 524:	bf30      	wfi
  while(1) {
 526:	e7fd      	b.n	524 <main+0x8>
 528:	00000478 	.word	0x00000478

0000052c <SystemCoreClockUpdate>:
    __root uint32_t SystemCoreClock = __SYSTEM_CLOCK_DEFAULT;
#endif    

void SystemCoreClockUpdate(void)
{
    switch(NRF_OSCILLATORS->PLL.CURRENTFREQ)
 52c:	4b07      	ldr	r3, [pc, #28]	@ (54c <SystemCoreClockUpdate+0x20>)
 52e:	f8d3 3804 	ldr.w	r3, [r3, #2052]	@ 0x804
 532:	2b01      	cmp	r3, #1
 534:	d006      	beq.n	544 <SystemCoreClockUpdate+0x18>
 536:	2b03      	cmp	r3, #3
 538:	d000      	beq.n	53c <SystemCoreClockUpdate+0x10>
            break;
        case OSCILLATORS_PLL_CURRENTFREQ_CURRENTFREQ_CK128M:
            SystemCoreClock = 128000000ul;
            break;
    }
}
 53a:	4770      	bx	lr
            SystemCoreClock = 64000000ul;
 53c:	4b04      	ldr	r3, [pc, #16]	@ (550 <SystemCoreClockUpdate+0x24>)
 53e:	4a05      	ldr	r2, [pc, #20]	@ (554 <SystemCoreClockUpdate+0x28>)
 540:	601a      	str	r2, [r3, #0]
            break;
 542:	4770      	bx	lr
            SystemCoreClock = 128000000ul;
 544:	4b02      	ldr	r3, [pc, #8]	@ (550 <SystemCoreClockUpdate+0x24>)
 546:	4a04      	ldr	r2, [pc, #16]	@ (558 <SystemCoreClockUpdate+0x2c>)
 548:	601a      	str	r2, [r3, #0]
}
 54a:	4770      	bx	lr
 54c:	50120000 	.word	0x50120000
 550:	20000000 	.word	0x20000000
 554:	03d09000 	.word	0x03d09000
 558:	07a12000 	.word	0x07a12000

0000055c <SystemInit>:
            #elif defined(NRF_CONFIG_CPU_FREQ_MHZ) && (NRF_CONFIG_CPU_FREQ_MHZ==128)
                NRF_OSCILLATORS->PLL.FREQ = OSCILLATORS_PLL_FREQ_FREQ_CK128M;
            #elif defined(NRF_CONFIG_CPU_FREQ_MHZ)
                #error "Illegal CPU frequency set"
            #else
                NRF_OSCILLATORS->PLL.FREQ = OSCILLATORS_PLL_FREQ_FREQ_CK128M;
 55c:	2301      	movs	r3, #1
    #else
        #if defined (NRF54L05_XXAA) || defined (DEVELOP_IN_NRF54L05)\
         || defined (NRF54L10_XXAA) || defined (DEVELOP_IN_NRF54L10)\
         || defined (NRF54L15_XXAA) || defined (DEVELOP_IN_NRF54L15)\
         || defined (NRF54LM20A_ENGA_XXAA) || defined (DEVELOP_IN_NRF54LM20A_ENGA)
            uint32_t var1 = *(uint32_t *)0x00FFC340ul;
 55e:	4a7b      	ldr	r2, [pc, #492]	@ (74c <SystemInit+0x1f0>)
 560:	497b      	ldr	r1, [pc, #492]	@ (750 <SystemInit+0x1f4>)
            uint32_t var2 = *(uint32_t *)0x00FFC344ul;
        #endif
        #if defined (NRF54L15_XXAA) || defined (DEVELOP_IN_NRF54L15)
            if (var1 == 0x1C)
 562:	f8d2 2340 	ldr.w	r2, [r2, #832]	@ 0x340
 566:	f8c1 3800 	str.w	r3, [r1, #2048]	@ 0x800
 56a:	2a1c      	cmp	r2, #28

            #if NRF54L_ERRATA_37_ENABLE_WORKAROUND
                /* Workaround for Errata 37 */
                if (nrf54l_errata_37())
                {
                    *((volatile uint32_t *)0x5005340C) = 1ul;
 56c:	bf04      	itt	eq
 56e:	4a79      	ldreq	r2, [pc, #484]	@ (754 <SystemInit+0x1f8>)
 570:	f8c2 340c 	streq.w	r3, [r2, #1036]	@ 0x40c
     TAMPC_PROTECT_DOMAIN_DBGEN_CTRL_KEY_KEY << TAMPC_PROTECT_DOMAIN_DBGEN_CTRL_KEY_Pos)


static inline void nrf54l_handle_approtect_signal(volatile uint32_t * signal_ctrl)
{
    if ((*signal_ctrl & TAMPC_SIGNAL_IS_LOCKED) != 0)
 574:	4b78      	ldr	r3, [pc, #480]	@ (758 <SystemInit+0x1fc>)
 576:	f8d3 2500 	ldr.w	r2, [r3, #1280]	@ 0x500
 57a:	0790      	lsls	r0, r2, #30
 57c:	d50d      	bpl.n	59a <SystemInit+0x3e>
    {
        if ((*signal_ctrl & TAMPC_SIGNAL_IS_HIGH) != 0)
 57e:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
 582:	07d9      	lsls	r1, r3, #31
 584:	d50f      	bpl.n	5a6 <SystemInit+0x4a>
            /* Do hard reset, invalid state. */
            
            /* Temporary fix - use WDT to trigger hard reset. */
            /* Replace with proper hard reset task later if added. */
            /* Make sure WDT is always running independent of CPU state. */
            NRF_WDT30->CONFIG = 9;
 586:	2009      	movs	r0, #9

            /* Set minimum tick length */
            NRF_WDT30->CRV = 0xF;
 588:	210f      	movs	r1, #15

            /* Start WDT */
            NRF_WDT30->TASKS_START = 1;
 58a:	2201      	movs	r2, #1
            NRF_WDT30->CONFIG = 9;
 58c:	4b73      	ldr	r3, [pc, #460]	@ (75c <SystemInit+0x200>)
 58e:	f8c3 050c 	str.w	r0, [r3, #1292]	@ 0x50c
            NRF_WDT30->CRV = 0xF;
 592:	f8c3 1504 	str.w	r1, [r3, #1284]	@ 0x504
            NRF_WDT30->TASKS_START = 1;
 596:	601a      	str	r2, [r3, #0]

            /* Wait for timer to elapse */
            while(1);
 598:	e7fe      	b.n	598 <SystemInit+0x3c>
    *signal_ctrl = TAMPC_SIGNAL_LOCK;
#elif defined(ENABLE_AUTHENTICATED_APPROTECT)
    /* Do nothing, TAMPC should already be in correct state. */
#else
    /* Disable APPROTECT */
    *signal_ctrl = TAMPC_SIGNAL_CLEAR_WRITEPROTECTION;
 59a:	4971      	ldr	r1, [pc, #452]	@ (760 <SystemInit+0x204>)
    *signal_ctrl = TAMPC_SIGNAL_OPEN;
 59c:	4a71      	ldr	r2, [pc, #452]	@ (764 <SystemInit+0x208>)
    *signal_ctrl = TAMPC_SIGNAL_CLEAR_WRITEPROTECTION;
 59e:	f8c3 1500 	str.w	r1, [r3, #1280]	@ 0x500
    *signal_ctrl = TAMPC_SIGNAL_OPEN;
 5a2:	f8c3 2500 	str.w	r2, [r3, #1280]	@ 0x500
    if ((*signal_ctrl & TAMPC_SIGNAL_IS_LOCKED) != 0)
 5a6:	4b6c      	ldr	r3, [pc, #432]	@ (758 <SystemInit+0x1fc>)
 5a8:	f8d3 2508 	ldr.w	r2, [r3, #1288]	@ 0x508
 5ac:	0792      	lsls	r2, r2, #30
 5ae:	d418      	bmi.n	5e2 <SystemInit+0x86>
    *signal_ctrl = TAMPC_SIGNAL_CLEAR_WRITEPROTECTION;
 5b0:	496b      	ldr	r1, [pc, #428]	@ (760 <SystemInit+0x204>)
    *signal_ctrl = TAMPC_SIGNAL_OPEN;
 5b2:	4a6c      	ldr	r2, [pc, #432]	@ (764 <SystemInit+0x208>)
    *signal_ctrl = TAMPC_SIGNAL_CLEAR_WRITEPROTECTION;
 5b4:	f8c3 1508 	str.w	r1, [r3, #1288]	@ 0x508
    *signal_ctrl = TAMPC_SIGNAL_OPEN;
 5b8:	f8c3 2508 	str.w	r2, [r3, #1288]	@ 0x508
#endif
}

static inline void nrf54l_handle_secureapprotect_signal(volatile uint32_t * signal_ctrl)
{
    if ((*signal_ctrl & TAMPC_SIGNAL_IS_LOCKED) != 0)
 5bc:	4b66      	ldr	r3, [pc, #408]	@ (758 <SystemInit+0x1fc>)
 5be:	f8d3 2510 	ldr.w	r2, [r3, #1296]	@ 0x510
 5c2:	0790      	lsls	r0, r2, #30
 5c4:	d51b      	bpl.n	5fe <SystemInit+0xa2>
    {
        if ((*signal_ctrl & TAMPC_SIGNAL_IS_HIGH) != 0)
 5c6:	f8d3 3510 	ldr.w	r3, [r3, #1296]	@ 0x510
 5ca:	07d9      	lsls	r1, r3, #31
 5cc:	d51d      	bpl.n	60a <SystemInit+0xae>
            NRF_WDT30->CONFIG = 9;
 5ce:	2009      	movs	r0, #9
            NRF_WDT30->CRV = 0xF;
 5d0:	210f      	movs	r1, #15
            NRF_WDT30->TASKS_START = 1;
 5d2:	2201      	movs	r2, #1
            NRF_WDT30->CONFIG = 9;
 5d4:	4b61      	ldr	r3, [pc, #388]	@ (75c <SystemInit+0x200>)
 5d6:	f8c3 050c 	str.w	r0, [r3, #1292]	@ 0x50c
            NRF_WDT30->CRV = 0xF;
 5da:	f8c3 1504 	str.w	r1, [r3, #1284]	@ 0x504
            NRF_WDT30->TASKS_START = 1;
 5de:	601a      	str	r2, [r3, #0]
            while(1);
 5e0:	e7fe      	b.n	5e0 <SystemInit+0x84>
        if ((*signal_ctrl & TAMPC_SIGNAL_IS_HIGH) != 0)
 5e2:	f8d3 3508 	ldr.w	r3, [r3, #1288]	@ 0x508
 5e6:	07db      	lsls	r3, r3, #31
 5e8:	d5e8      	bpl.n	5bc <SystemInit+0x60>
            NRF_WDT30->CONFIG = 9;
 5ea:	2009      	movs	r0, #9
            NRF_WDT30->CRV = 0xF;
 5ec:	210f      	movs	r1, #15
            NRF_WDT30->TASKS_START = 1;
 5ee:	2201      	movs	r2, #1
            NRF_WDT30->CONFIG = 9;
 5f0:	4b5a      	ldr	r3, [pc, #360]	@ (75c <SystemInit+0x200>)
 5f2:	f8c3 050c 	str.w	r0, [r3, #1292]	@ 0x50c
            NRF_WDT30->CRV = 0xF;
 5f6:	f8c3 1504 	str.w	r1, [r3, #1284]	@ 0x504
            NRF_WDT30->TASKS_START = 1;
 5fa:	601a      	str	r2, [r3, #0]
            while(1);
 5fc:	e7fe      	b.n	5fc <SystemInit+0xa0>
#elif defined(ENABLE_AUTHENTICATED_SECUREAPPROTECT)
    /* Do nothing, TAMPC should already be in correct state. */
    // TODO: What about if approtect is disabled here?
#else
    /* Disable APPROTECT */
    *signal_ctrl = TAMPC_SIGNAL_CLEAR_WRITEPROTECTION;
 5fe:	4958      	ldr	r1, [pc, #352]	@ (760 <SystemInit+0x204>)
    *signal_ctrl = TAMPC_SIGNAL_OPEN;
 600:	4a58      	ldr	r2, [pc, #352]	@ (764 <SystemInit+0x208>)
    *signal_ctrl = TAMPC_SIGNAL_CLEAR_WRITEPROTECTION;
 602:	f8c3 1510 	str.w	r1, [r3, #1296]	@ 0x510
    *signal_ctrl = TAMPC_SIGNAL_OPEN;
 606:	f8c3 2510 	str.w	r2, [r3, #1296]	@ 0x510
    if ((*signal_ctrl & TAMPC_SIGNAL_IS_LOCKED) != 0)
 60a:	4b53      	ldr	r3, [pc, #332]	@ (758 <SystemInit+0x1fc>)
 60c:	f8d3 2518 	ldr.w	r2, [r3, #1304]	@ 0x518
 610:	0792      	lsls	r2, r2, #30
 612:	d418      	bmi.n	646 <SystemInit+0xea>
    *signal_ctrl = TAMPC_SIGNAL_CLEAR_WRITEPROTECTION;
 614:	4952      	ldr	r1, [pc, #328]	@ (760 <SystemInit+0x204>)
    *signal_ctrl = TAMPC_SIGNAL_OPEN;
 616:	4a53      	ldr	r2, [pc, #332]	@ (764 <SystemInit+0x208>)
    *signal_ctrl = TAMPC_SIGNAL_CLEAR_WRITEPROTECTION;
 618:	f8c3 1518 	str.w	r1, [r3, #1304]	@ 0x518
    *signal_ctrl = TAMPC_SIGNAL_OPEN;
 61c:	f8c3 2518 	str.w	r2, [r3, #1304]	@ 0x518
    if ((*signal_ctrl & TAMPC_SIGNAL_IS_LOCKED) != 0)
 620:	4b4d      	ldr	r3, [pc, #308]	@ (758 <SystemInit+0x1fc>)
 622:	f8d3 2700 	ldr.w	r2, [r3, #1792]	@ 0x700
 626:	0790      	lsls	r0, r2, #30
 628:	d51b      	bpl.n	662 <SystemInit+0x106>
        if ((*signal_ctrl & TAMPC_SIGNAL_IS_HIGH) != 0)
 62a:	f8d3 3700 	ldr.w	r3, [r3, #1792]	@ 0x700
 62e:	07d9      	lsls	r1, r3, #31
 630:	d51d      	bpl.n	66e <SystemInit+0x112>
            NRF_WDT30->CONFIG = 9;
 632:	2009      	movs	r0, #9
            NRF_WDT30->CRV = 0xF;
 634:	210f      	movs	r1, #15
            NRF_WDT30->TASKS_START = 1;
 636:	2201      	movs	r2, #1
            NRF_WDT30->CONFIG = 9;
 638:	4b48      	ldr	r3, [pc, #288]	@ (75c <SystemInit+0x200>)
 63a:	f8c3 050c 	str.w	r0, [r3, #1292]	@ 0x50c
            NRF_WDT30->CRV = 0xF;
 63e:	f8c3 1504 	str.w	r1, [r3, #1284]	@ 0x504
            NRF_WDT30->TASKS_START = 1;
 642:	601a      	str	r2, [r3, #0]
            while(1);
 644:	e7fe      	b.n	644 <SystemInit+0xe8>
        if ((*signal_ctrl & TAMPC_SIGNAL_IS_HIGH) != 0)
 646:	f8d3 3518 	ldr.w	r3, [r3, #1304]	@ 0x518
 64a:	07db      	lsls	r3, r3, #31
 64c:	d5e8      	bpl.n	620 <SystemInit+0xc4>
            NRF_WDT30->CONFIG = 9;
 64e:	2009      	movs	r0, #9
            NRF_WDT30->CRV = 0xF;
 650:	210f      	movs	r1, #15
            NRF_WDT30->TASKS_START = 1;
 652:	2201      	movs	r2, #1
            NRF_WDT30->CONFIG = 9;
 654:	4b41      	ldr	r3, [pc, #260]	@ (75c <SystemInit+0x200>)
 656:	f8c3 050c 	str.w	r0, [r3, #1292]	@ 0x50c
            NRF_WDT30->CRV = 0xF;
 65a:	f8c3 1504 	str.w	r1, [r3, #1284]	@ 0x504
            NRF_WDT30->TASKS_START = 1;
 65e:	601a      	str	r2, [r3, #0]
            while(1);
 660:	e7fe      	b.n	660 <SystemInit+0x104>
    *signal_ctrl = TAMPC_SIGNAL_CLEAR_WRITEPROTECTION;
 662:	493f      	ldr	r1, [pc, #252]	@ (760 <SystemInit+0x204>)
    *signal_ctrl = TAMPC_SIGNAL_OPEN;
 664:	4a3f      	ldr	r2, [pc, #252]	@ (764 <SystemInit+0x208>)
    *signal_ctrl = TAMPC_SIGNAL_CLEAR_WRITEPROTECTION;
 666:	f8c3 1700 	str.w	r1, [r3, #1792]	@ 0x700
    *signal_ctrl = TAMPC_SIGNAL_OPEN;
 66a:	f8c3 2700 	str.w	r2, [r3, #1792]	@ 0x700
                nrf54l_handle_approtect();
            #endif
            #if defined(__FPU_PRESENT) && __FPU_PRESENT
                /* Allow Non-Secure code to run FPU instructions.
                * If only the secure code should control FPU power state these registers should be configured accordingly in the secure application code. */
                SCB->NSACR |= (3UL << 10ul);
 66e:	493e      	ldr	r1, [pc, #248]	@ (768 <SystemInit+0x20c>)
                    #endif
                    * ((volatile uint32_t*)NRF_FICR->TRIMCNF[index].ADDR) = NRF_FICR->TRIMCNF[index].DATA;

                #else

                    for (index = 0ul; index < FICR_TRIMCNF_MaxCount && NRF_FICR_NS->TRIMCNF[index].ADDR != 0xFFFFFFFFul && NRF_FICR_NS->TRIMCNF[index].ADDR != 0x00000000ul; index++) {
 670:	2200      	movs	r2, #0
                SCB->NSACR |= (3UL << 10ul);
 672:	f8d1 308c 	ldr.w	r3, [r1, #140]	@ 0x8c
 676:	f443 6340 	orr.w	r3, r3, #3072	@ 0xc00
 67a:	f8c1 308c 	str.w	r3, [r1, #140]	@ 0x8c
                    for (index = 0ul; index < FICR_TRIMCNF_MaxCount && NRF_FICR_NS->TRIMCNF[index].ADDR != 0xFFFFFFFFul && NRF_FICR_NS->TRIMCNF[index].ADDR != 0x00000000ul; index++) {
 67e:	e009      	b.n	694 <SystemInit+0x138>
 680:	f8d3 1400 	ldr.w	r1, [r3, #1024]	@ 0x400
 684:	b181      	cbz	r1, 6a8 <SystemInit+0x14c>
                    #if defined ( __ICCARM__ )
                        /* IAR will complain about the order of volatile pointer accesses. */
                        #pragma diag_suppress=Pa082
                    #endif
                    * ((volatile uint32_t*)NRF_FICR_NS->TRIMCNF[index].ADDR) = NRF_FICR_NS->TRIMCNF[index].DATA;
 686:	f8d3 1400 	ldr.w	r1, [r3, #1024]	@ 0x400
 68a:	f8d3 3404 	ldr.w	r3, [r3, #1028]	@ 0x404
                    for (index = 0ul; index < FICR_TRIMCNF_MaxCount && NRF_FICR_NS->TRIMCNF[index].ADDR != 0xFFFFFFFFul && NRF_FICR_NS->TRIMCNF[index].ADDR != 0x00000000ul; index++) {
 68e:	2a40      	cmp	r2, #64	@ 0x40
                    * ((volatile uint32_t*)NRF_FICR_NS->TRIMCNF[index].ADDR) = NRF_FICR_NS->TRIMCNF[index].DATA;
 690:	600b      	str	r3, [r1, #0]
                    for (index = 0ul; index < FICR_TRIMCNF_MaxCount && NRF_FICR_NS->TRIMCNF[index].ADDR != 0xFFFFFFFFul && NRF_FICR_NS->TRIMCNF[index].ADDR != 0x00000000ul; index++) {
 692:	d009      	beq.n	6a8 <SystemInit+0x14c>
                    * ((volatile uint32_t*)NRF_FICR_NS->TRIMCNF[index].ADDR) = NRF_FICR_NS->TRIMCNF[index].DATA;
 694:	00d3      	lsls	r3, r2, #3
 696:	f503 037f 	add.w	r3, r3, #16711680	@ 0xff0000
 69a:	f503 4340 	add.w	r3, r3, #49152	@ 0xc000
                    for (index = 0ul; index < FICR_TRIMCNF_MaxCount && NRF_FICR_NS->TRIMCNF[index].ADDR != 0xFFFFFFFFul && NRF_FICR_NS->TRIMCNF[index].ADDR != 0x00000000ul; index++) {
 69e:	f8d3 1400 	ldr.w	r1, [r3, #1024]	@ 0x400
 6a2:	3201      	adds	r2, #1
 6a4:	3101      	adds	r1, #1
 6a6:	d1eb      	bne.n	680 <SystemInit+0x124>
                }
            #endif //NRF_DISABLE_FICR_TRIMCNF

            /* Device configuration for ES PDK */
            #if defined (NRF54L05_XXAA) || defined (NRF54L10_XXAA) || defined (NRF54L15_XXAA)
                if (*((volatile uint32_t *)0x50120440) == 0x00ul) {
 6a8:	4b29      	ldr	r3, [pc, #164]	@ (750 <SystemInit+0x1f4>)
 6aa:	f8d3 2440 	ldr.w	r2, [r3, #1088]	@ 0x440
 6ae:	b912      	cbnz	r2, 6b6 <SystemInit+0x15a>
                    *((volatile uint32_t *)0x50120440) = 0xC8ul;
 6b0:	22c8      	movs	r2, #200	@ 0xc8
 6b2:	f8c3 2440 	str.w	r2, [r3, #1088]	@ 0x440
            uint32_t var2 = *(uint32_t *)0x00FFC344ul;
 6b6:	4b25      	ldr	r3, [pc, #148]	@ (74c <SystemInit+0x1f0>)
 6b8:	e9d3 21d0 	ldrd	r2, r1, [r3, #832]	@ 0x340
            if (var1 == 0x1C)
 6bc:	2a1c      	cmp	r2, #28
 6be:	d018      	beq.n	6f2 <SystemInit+0x196>
                }
            #endif

            #ifndef NRF_DISABLE_RRAM_POWER_OFF
                /* Allow RRAMC to go into poweroff mode during System on idle for lower power consumption at a penalty of 9us extra RRAM ready time */
                NRF_RRAMC->POWER.LOWPOWERCONFIG = (RRAMC_POWER_LOWPOWERCONFIG_MODE_PowerOff << RRAMC_POWER_LOWPOWERCONFIG_MODE_Pos);
 6c0:	2203      	movs	r2, #3
 6c2:	492a      	ldr	r1, [pc, #168]	@ (76c <SystemInit+0x210>)
        * compiler. Since the FPU consumes energy, remember to disable FPU use in the compiler if floating point unit
        * operations are not used in your code. */
        
        /* Allow Non-Secure code to run FPU instructions.
         * If only the secure code should control FPU power state these registers should be configured accordingly in the secure application code. */
        SCB->NSACR |= (3UL << 10ul);
 6c4:	4b28      	ldr	r3, [pc, #160]	@ (768 <SystemInit+0x20c>)
                NRF_RRAMC->POWER.LOWPOWERCONFIG = (RRAMC_POWER_LOWPOWERCONFIG_MODE_PowerOff << RRAMC_POWER_LOWPOWERCONFIG_MODE_Pos);
 6c6:	f8c1 2518 	str.w	r2, [r1, #1304]	@ 0x518
        SCB->NSACR |= (3UL << 10ul);
 6ca:	f8d3 208c 	ldr.w	r2, [r3, #140]	@ 0x8c
 6ce:	f442 6240 	orr.w	r2, r2, #3072	@ 0xc00
 6d2:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c

        #if (__FPU_USED == 1ul)
            SCB->CPACR |= (3UL << 20ul) | (3UL << 22ul);
 6d6:	f8d3 2088 	ldr.w	r2, [r3, #136]	@ 0x88
 6da:	f442 0270 	orr.w	r2, r2, #15728640	@ 0xf00000
 6de:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 6e2:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 6e6:	f3bf 8f6f 	isb	sy
        #if !defined(NRF_TRUSTZONE_NONSECURE) && !defined (NRF_SKIP_GLITCHDETECTOR_DISABLE) && defined(GLITCHDET_PRESENT)
            /* Disable glitch detector */
            #if defined (GLITCHDET_GLITCHDETECTORS)
                NRF_GLITCHDET_S->GLITCHDETECTOR.CONFIG = (GLITCHDET_GLITCHDETECTOR_CONFIG_ENABLE_Disable << GLITCHDET_GLITCHDETECTOR_CONFIG_ENABLE_Pos);
            #else
                NRF_GLITCHDET_S->CONFIG = (GLITCHDET_CONFIG_ENABLE_Disable << GLITCHDET_CONFIG_ENABLE_Pos);
 6ea:	2300      	movs	r3, #0
 6ec:	f8c1 35a0 	str.w	r3, [r1, #1440]	@ 0x5a0
                }
            #endif
        #endif

    #endif
}
 6f0:	4770      	bx	lr
                switch(var2)
 6f2:	2901      	cmp	r1, #1
 6f4:	d009      	beq.n	70a <SystemInit+0x1ae>
                    if (NRF_RESET->RESETREAS & RESET_RESETREAS_RESETPIN_Msk)
 6f6:	4b1e      	ldr	r3, [pc, #120]	@ (770 <SystemInit+0x214>)
 6f8:	f8d3 2600 	ldr.w	r2, [r3, #1536]	@ 0x600
 6fc:	07d2      	lsls	r2, r2, #31
 6fe:	d5df      	bpl.n	6c0 <SystemInit+0x164>
                        NRF_RESET->RESETREAS =  ~RESET_RESETREAS_RESETPIN_Msk;
 700:	f06f 0201 	mvn.w	r2, #1
 704:	f8c3 2600 	str.w	r2, [r3, #1536]	@ 0x600
 708:	e7da      	b.n	6c0 <SystemInit+0x164>
                    if (*((volatile uint32_t *)0x00FFC334ul) <= 0x180A1D00ul){
 70a:	f8d3 2334 	ldr.w	r2, [r3, #820]	@ 0x334
 70e:	4b19      	ldr	r3, [pc, #100]	@ (774 <SystemInit+0x218>)
 710:	429a      	cmp	r2, r3
 712:	d803      	bhi.n	71c <SystemInit+0x1c0>
                        *((volatile uint32_t *)0x50120640ul) = 0x1EA9E040ul;
 714:	4b0e      	ldr	r3, [pc, #56]	@ (750 <SystemInit+0x1f4>)
 716:	4a18      	ldr	r2, [pc, #96]	@ (778 <SystemInit+0x21c>)
 718:	f8c3 2640 	str.w	r2, [r3, #1600]	@ 0x640
            uint32_t var2 = *(uint32_t *)0x00FFC344ul;
 71c:	4b0b      	ldr	r3, [pc, #44]	@ (74c <SystemInit+0x1f0>)
                    *((volatile uint32_t *)0x5008A7ACul) = 0x040A0078ul;
 71e:	4917      	ldr	r1, [pc, #92]	@ (77c <SystemInit+0x220>)
            if (var1 == 0x1C)
 720:	f8d3 2340 	ldr.w	r2, [r3, #832]	@ 0x340
 724:	4816      	ldr	r0, [pc, #88]	@ (780 <SystemInit+0x224>)
 726:	2a1c      	cmp	r2, #28
 728:	f8c1 07ac 	str.w	r0, [r1, #1964]	@ 0x7ac
            uint32_t var2 = *(uint32_t *)0x00FFC344ul;
 72c:	f8d3 3344 	ldr.w	r3, [r3, #836]	@ 0x344
            if (var1 == 0x1C)
 730:	d1c6      	bne.n	6c0 <SystemInit+0x164>
                switch(var2)
 732:	2b01      	cmp	r3, #1
 734:	d1df      	bne.n	6f6 <SystemInit+0x19a>
                    *((volatile uint32_t *)0x50120624ul) = (20 | (1<<5));
 736:	2234      	movs	r2, #52	@ 0x34
 738:	4b05      	ldr	r3, [pc, #20]	@ (750 <SystemInit+0x1f4>)
 73a:	f8c3 2624 	str.w	r2, [r3, #1572]	@ 0x624
                    *((volatile uint32_t *)0x5012063Cul) &= ~(1ul << 19);
 73e:	f8d3 263c 	ldr.w	r2, [r3, #1596]	@ 0x63c
 742:	f422 2200 	bic.w	r2, r2, #524288	@ 0x80000
 746:	f8c3 263c 	str.w	r2, [r3, #1596]	@ 0x63c
         || defined (NRF54LM20A_ENGA_XXAA) || defined (DEVELOP_IN_NRF54LM20A_ENGA)
            uint32_t var1 = *(uint32_t *)0x00FFC340ul;
            uint32_t var2 = *(uint32_t *)0x00FFC344ul;
        #endif
        #if defined (NRF54L15_XXAA) || defined (DEVELOP_IN_NRF54L15)
            if (var1 == 0x1C)
 74a:	e7d4      	b.n	6f6 <SystemInit+0x19a>
 74c:	00ffc000 	.word	0x00ffc000
 750:	50120000 	.word	0x50120000
 754:	50053000 	.word	0x50053000
 758:	500dc000 	.word	0x500dc000
 75c:	50108000 	.word	0x50108000
 760:	50fa00f0 	.word	0x50fa00f0
 764:	50fa0001 	.word	0x50fa0001
 768:	e000ed00 	.word	0xe000ed00
 76c:	5004b000 	.word	0x5004b000
 770:	5010e000 	.word	0x5010e000
 774:	180a1d00 	.word	0x180a1d00
 778:	1ea9e040 	.word	0x1ea9e040
 77c:	5008a000 	.word	0x5008a000
 780:	040a0078 	.word	0x040a0078

00000784 <printi.constprop.0>:
	}

	return pc;
}

static int printi(char **out, int i, int b, int sg, int width, int pad, int letbase)
 784:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 788:	b084      	sub	sp, #16
 78a:	f8dd 8030 	ldr.w	r8, [sp, #48]	@ 0x30
 78e:	461e      	mov	r6, r3
	if (!(pad & PAD_RIGHT)) {
 790:	f008 0901 	and.w	r9, r8, #1
	char print_buf[PRINT_BUF_LEN];
	register char *s;
	register int t, neg = 0, pc = 0;
	register unsigned int u = i;

	if (i == 0) {
 794:	2800      	cmp	r0, #0
 796:	f000 808a 	beq.w	8ae <Heap_Size+0xae>
		print_buf[0] = '0';
		print_buf[1] = '\0';
		return prints (out, print_buf, width, pad);
	}

	if (sg && b == 10 && i < 0) {
 79a:	4617      	mov	r7, r2
 79c:	2a00      	cmp	r2, #0
 79e:	d163      	bne.n	868 <Heap_Size+0x68>
		neg = 1;
		u = -i;
	}

	s = print_buf + PRINT_BUF_LEN-1;
	*s = '\0';
 7a0:	2300      	movs	r3, #0

	while (u) {
		t = u % b;
		if( t >= 10 )
			t += letbase - '0' - 10;
 7a2:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
	*s = '\0';
 7a4:	f88d 300f 	strb.w	r3, [sp, #15]
			t += letbase - '0' - 10;
 7a8:	f1a2 0e3a 	sub.w	lr, r2, #58	@ 0x3a
	s = print_buf + PRINT_BUF_LEN-1;
 7ac:	f10d 030f 	add.w	r3, sp, #15
 7b0:	e005      	b.n	7be <printi.constprop.0+0x3a>
	while (u) {
 7b2:	4281      	cmp	r1, r0
		*--s = t + '0';
 7b4:	f803 4c01 	strb.w	r4, [r3, #-1]
	while (u) {
 7b8:	d818      	bhi.n	7ec <printi.constprop.0+0x68>
		*--s = t + '0';
 7ba:	462b      	mov	r3, r5
		u /= b;
 7bc:	4610      	mov	r0, r2
		t = u % b;
 7be:	fbb0 f2f1 	udiv	r2, r0, r1
 7c2:	fb01 0c12 	mls	ip, r1, r2, r0
			t += letbase - '0' - 10;
 7c6:	eb0e 040c 	add.w	r4, lr, ip
		*--s = t + '0';
 7ca:	3430      	adds	r4, #48	@ 0x30
		if( t >= 10 )
 7cc:	f1bc 0f09 	cmp.w	ip, #9
		*--s = t + '0';
 7d0:	f103 35ff 	add.w	r5, r3, #4294967295	@ 0xffffffff
 7d4:	f10c 0a30 	add.w	sl, ip, #48	@ 0x30
 7d8:	b2e4      	uxtb	r4, r4
		if( t >= 10 )
 7da:	d8ea      	bhi.n	7b2 <printi.constprop.0+0x2e>
		*--s = t + '0';
 7dc:	fa5f f48a 	uxtb.w	r4, sl
	while (u) {
 7e0:	4281      	cmp	r1, r0
		*--s = t + '0';
 7e2:	f803 4c01 	strb.w	r4, [r3, #-1]
 7e6:	f103 35ff 	add.w	r5, r3, #4294967295	@ 0xffffffff
	while (u) {
 7ea:	d9e6      	bls.n	7ba <printi.constprop.0+0x36>
	}

	if (neg) {
 7ec:	b147      	cbz	r7, 800 <Heap_Size>
		if( width && (pad & PAD_ZERO) ) {
 7ee:	2e00      	cmp	r6, #0
 7f0:	d06a      	beq.n	8c8 <Heap_Size+0xc8>
 7f2:	f018 0202 	ands.w	r2, r8, #2
 7f6:	d07b      	beq.n	8f0 <Heap_Size+0xf0>
    hal_uarte_char_write(c);
 7f8:	202d      	movs	r0, #45	@ 0x2d
 7fa:	f000 fa59 	bl	cb0 <hal_uarte_char_write>
			printchar (out, '-');
			++pc;
			--width;
 7fe:	3e01      	subs	r6, #1
	if (width > 0) {
 800:	2e00      	cmp	r6, #0
 802:	dd4f      	ble.n	8a4 <Heap_Size+0xa4>
		for (ptr = string; *ptr; ++ptr) ++len;
 804:	462b      	mov	r3, r5
 806:	4619      	mov	r1, r3
 808:	f813 2f01 	ldrb.w	r2, [r3, #1]!
 80c:	2a00      	cmp	r2, #0
 80e:	d1fa      	bne.n	806 <Heap_Size+0x6>
 810:	f1c5 0301 	rsb	r3, r5, #1
 814:	4419      	add	r1, r3
		if (len >= width) width = 0;
 816:	428e      	cmp	r6, r1
 818:	dc2a      	bgt.n	870 <Heap_Size+0x70>
		if (pad & PAD_ZERO) padchar = '0';
 81a:	f018 0802 	ands.w	r8, r8, #2
 81e:	d05c      	beq.n	8da <Heap_Size+0xda>
	if (!(pad & PAD_RIGHT)) {
 820:	f1b9 0f00 	cmp.w	r9, #0
 824:	d06f      	beq.n	906 <Heap_Size+0x106>
	register int pc = 0, padchar = ' ';
 826:	4616      	mov	r6, r2
	if (!(pad & PAD_RIGHT)) {
 828:	f04f 0a30 	mov.w	sl, #48	@ 0x30
		if (len >= width) width = 0;
 82c:	4690      	mov	r8, r2
 82e:	46a9      	mov	r9, r5
    hal_uarte_char_write(c);
 830:	4620      	mov	r0, r4
 832:	f000 fa3d 	bl	cb0 <hal_uarte_char_write>
	for ( ; *string ; ++string) {
 836:	464b      	mov	r3, r9
 838:	f819 4f01 	ldrb.w	r4, [r9, #1]!
 83c:	2c00      	cmp	r4, #0
 83e:	d1f7      	bne.n	830 <Heap_Size+0x30>
 840:	3601      	adds	r6, #1
 842:	1b76      	subs	r6, r6, r5
 844:	441e      	add	r6, r3
	for ( ; width > 0; --width) {
 846:	f1b8 0f00 	cmp.w	r8, #0
		else {
			*--s = '-';
		}
	}

	return pc + prints (out, s, width, pad);
 84a:	bfd8      	it	le
 84c:	19f0      	addle	r0, r6, r7
	for ( ; width > 0; --width) {
 84e:	dd08      	ble.n	862 <Heap_Size+0x62>
 850:	4644      	mov	r4, r8
    hal_uarte_char_write(c);
 852:	4650      	mov	r0, sl
 854:	f000 fa2c 	bl	cb0 <hal_uarte_char_write>
	for ( ; width > 0; --width) {
 858:	3c01      	subs	r4, #1
 85a:	d1fa      	bne.n	852 <Heap_Size+0x52>
	return pc + prints (out, s, width, pad);
 85c:	44b0      	add	r8, r6
 85e:	eb08 0007 	add.w	r0, r8, r7
}
 862:	b004      	add	sp, #16
 864:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (sg && b == 10 && i < 0) {
 868:	290a      	cmp	r1, #10
 86a:	d03d      	beq.n	8e8 <Heap_Size+0xe8>
	register int t, neg = 0, pc = 0;
 86c:	2700      	movs	r7, #0
 86e:	e797      	b.n	7a0 <printi.constprop.0+0x1c>
		if (pad & PAD_ZERO) padchar = '0';
 870:	f018 0f02 	tst.w	r8, #2
		else width -= len;
 874:	eba6 0601 	sub.w	r6, r6, r1
		if (pad & PAD_ZERO) padchar = '0';
 878:	bf14      	ite	ne
 87a:	f04f 0a30 	movne.w	sl, #48	@ 0x30
 87e:	f04f 0a20 	moveq.w	sl, #32
	if (!(pad & PAD_RIGHT)) {
 882:	46b0      	mov	r8, r6
 884:	f1b9 0f00 	cmp.w	r9, #0
 888:	d10f      	bne.n	8aa <Heap_Size+0xaa>
    hal_uarte_char_write(c);
 88a:	4650      	mov	r0, sl
 88c:	f000 fa10 	bl	cb0 <hal_uarte_char_write>
		for ( ; width > 0; --width) {
 890:	f1b8 0801 	subs.w	r8, r8, #1
 894:	d0cb      	beq.n	82e <Heap_Size+0x2e>
    hal_uarte_char_write(c);
 896:	4650      	mov	r0, sl
 898:	f000 fa0a 	bl	cb0 <hal_uarte_char_write>
		for ( ; width > 0; --width) {
 89c:	f1b8 0801 	subs.w	r8, r8, #1
 8a0:	d1f3      	bne.n	88a <Heap_Size+0x8a>
 8a2:	e7c4      	b.n	82e <Heap_Size+0x2e>
 8a4:	46b0      	mov	r8, r6
 8a6:	f04f 0a20 	mov.w	sl, #32
 8aa:	2600      	movs	r6, #0
 8ac:	e7bf      	b.n	82e <Heap_Size+0x2e>
		print_buf[0] = '0';
 8ae:	2030      	movs	r0, #48	@ 0x30
	if (width > 0) {
 8b0:	2b00      	cmp	r3, #0
		print_buf[0] = '0';
 8b2:	f8ad 0004 	strh.w	r0, [sp, #4]
	if (width > 0) {
 8b6:	dd03      	ble.n	8c0 <Heap_Size+0xc0>
		if (len >= width) width = 0;
 8b8:	2e01      	cmp	r6, #1
		if (pad & PAD_ZERO) padchar = '0';
 8ba:	f008 0302 	and.w	r3, r8, #2
		if (len >= width) width = 0;
 8be:	d125      	bne.n	90c <Heap_Size+0x10c>
    hal_uarte_char_write(c);
 8c0:	f000 f9f6 	bl	cb0 <hal_uarte_char_write>
		return prints (out, print_buf, width, pad);
 8c4:	2001      	movs	r0, #1
 8c6:	e7cc      	b.n	862 <Heap_Size+0x62>
			*--s = '-';
 8c8:	242d      	movs	r4, #45	@ 0x2d
	register int t, neg = 0, pc = 0;
 8ca:	4637      	mov	r7, r6
			*--s = '-';
 8cc:	f805 4c01 	strb.w	r4, [r5, #-1]
 8d0:	46b0      	mov	r8, r6
 8d2:	f04f 0a20 	mov.w	sl, #32
 8d6:	1e9d      	subs	r5, r3, #2
 8d8:	e7a9      	b.n	82e <Heap_Size+0x2e>
	if (!(pad & PAD_RIGHT)) {
 8da:	f1b9 0f00 	cmp.w	r9, #0
 8de:	d00d      	beq.n	8fc <Heap_Size+0xfc>
	register int pc = 0, padchar = ' ';
 8e0:	4646      	mov	r6, r8
	if (!(pad & PAD_RIGHT)) {
 8e2:	f04f 0a20 	mov.w	sl, #32
 8e6:	e7a2      	b.n	82e <Heap_Size+0x2e>
	if (sg && b == 10 && i < 0) {
 8e8:	2800      	cmp	r0, #0
 8ea:	dabf      	bge.n	86c <Heap_Size+0x6c>
		u = -i;
 8ec:	4240      	negs	r0, r0
	while (u) {
 8ee:	e757      	b.n	7a0 <printi.constprop.0+0x1c>
			*--s = '-';
 8f0:	242d      	movs	r4, #45	@ 0x2d
	register int t, neg = 0, pc = 0;
 8f2:	4617      	mov	r7, r2
			*--s = '-';
 8f4:	f805 4c01 	strb.w	r4, [r5, #-1]
 8f8:	1e9d      	subs	r5, r3, #2
 8fa:	e781      	b.n	800 <Heap_Size>
	if (!(pad & PAD_RIGHT)) {
 8fc:	f04f 0a20 	mov.w	sl, #32
	for ( ; *string ; ++string) {
 900:	2600      	movs	r6, #0
 902:	46b0      	mov	r8, r6
 904:	e793      	b.n	82e <Heap_Size+0x2e>
	if (!(pad & PAD_RIGHT)) {
 906:	f04f 0a30 	mov.w	sl, #48	@ 0x30
 90a:	e7f9      	b.n	900 <Heap_Size+0x100>
		else width -= len;
 90c:	1e74      	subs	r4, r6, #1
		if (pad & PAD_ZERO) padchar = '0';
 90e:	b18b      	cbz	r3, 934 <Heap_Size+0x134>
 910:	4607      	mov	r7, r0
 912:	4605      	mov	r5, r0
	if (!(pad & PAD_RIGHT)) {
 914:	f1b9 0f00 	cmp.w	r9, #0
 918:	d00f      	beq.n	93a <Heap_Size+0x13a>
    hal_uarte_char_write(c);
 91a:	2030      	movs	r0, #48	@ 0x30
 91c:	f000 f9c8 	bl	cb0 <hal_uarte_char_write>
 920:	b2ed      	uxtb	r5, r5
 922:	4628      	mov	r0, r5
 924:	f000 f9c4 	bl	cb0 <hal_uarte_char_write>
	for ( ; width > 0; --width) {
 928:	3c01      	subs	r4, #1
 92a:	d1fa      	bne.n	922 <Heap_Size+0x122>
		return prints (out, print_buf, width, pad);
 92c:	4630      	mov	r0, r6
}
 92e:	b004      	add	sp, #16
 930:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		if (pad & PAD_ZERO) padchar = '0';
 934:	2720      	movs	r7, #32
	register int pc = 0, padchar = ' ';
 936:	463d      	mov	r5, r7
 938:	e7ec      	b.n	914 <Heap_Size+0x114>
    hal_uarte_char_write(c);
 93a:	4638      	mov	r0, r7
 93c:	f000 f9b8 	bl	cb0 <hal_uarte_char_write>
		for ( ; width > 0; --width) {
 940:	3c01      	subs	r4, #1
 942:	d1fa      	bne.n	93a <Heap_Size+0x13a>
    hal_uarte_char_write(c);
 944:	2030      	movs	r0, #48	@ 0x30
 946:	f000 f9b3 	bl	cb0 <hal_uarte_char_write>
		return prints (out, print_buf, width, pad);
 94a:	4630      	mov	r0, r6
 94c:	e7ef      	b.n	92e <Heap_Size+0x12e>
 94e:	bf00      	nop

00000950 <print.constprop.0>:

static int print(char **out, const char *format, va_list args )
 950:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 954:	4605      	mov	r5, r0
{
	register int width, pad;
	register int pc = 0;
	char scr[2];

	for (; *format != 0; ++format) {
 956:	7800      	ldrb	r0, [r0, #0]
static int print(char **out, const char *format, va_list args )
 958:	b083      	sub	sp, #12
	for (; *format != 0; ++format) {
 95a:	2800      	cmp	r0, #0
 95c:	f000 8082 	beq.w	a64 <__text_size+0xe8>
 960:	460f      	mov	r7, r1
	register int pc = 0;
 962:	2600      	movs	r6, #0
 964:	e007      	b.n	976 <print.constprop.0+0x26>
    hal_uarte_char_write(c);
 966:	f000 f9a3 	bl	cb0 <hal_uarte_char_write>
			}
		}
		else {
		out:
			printchar (out, *format);
			++pc;
 96a:	462c      	mov	r4, r5
 96c:	3601      	adds	r6, #1
	for (; *format != 0; ++format) {
 96e:	7860      	ldrb	r0, [r4, #1]
 970:	1c65      	adds	r5, r4, #1
 972:	2800      	cmp	r0, #0
 974:	d077      	beq.n	a66 <__text_size+0xea>
		if (*format == '%') {
 976:	2825      	cmp	r0, #37	@ 0x25
 978:	d1f5      	bne.n	966 <print.constprop.0+0x16>
			if (*format == '\0') break;
 97a:	7868      	ldrb	r0, [r5, #1]
 97c:	2800      	cmp	r0, #0
 97e:	d072      	beq.n	a66 <__text_size+0xea>
			if (*format == '%') goto out;
 980:	2825      	cmp	r0, #37	@ 0x25
			++format;
 982:	f105 0401 	add.w	r4, r5, #1
			if (*format == '%') goto out;
 986:	d06b      	beq.n	a60 <__text_size+0xe4>
			if (*format == '-') {
 988:	282d      	cmp	r0, #45	@ 0x2d
			while (*format == '0') {
 98a:	bf05      	ittet	eq
 98c:	78a8      	ldrbeq	r0, [r5, #2]
				pad = PAD_RIGHT;
 98e:	2201      	moveq	r2, #1
			width = pad = 0;
 990:	2200      	movne	r2, #0
				++format;
 992:	1cac      	addeq	r4, r5, #2
			while (*format == '0') {
 994:	2830      	cmp	r0, #48	@ 0x30
 996:	f040 80da 	bne.w	b4e <__text_size+0x1d2>
 99a:	f814 0f01 	ldrb.w	r0, [r4, #1]!
				pad |= PAD_ZERO;
 99e:	f042 0202 	orr.w	r2, r2, #2
			while (*format == '0') {
 9a2:	2830      	cmp	r0, #48	@ 0x30
 9a4:	d0f9      	beq.n	99a <__text_size+0x1e>
 9a6:	f04f 0c02 	mov.w	ip, #2
			for ( ; *format >= '0' && *format <= '9'; ++format) {
 9aa:	f1a0 0330 	sub.w	r3, r0, #48	@ 0x30
 9ae:	b2d9      	uxtb	r1, r3
 9b0:	2909      	cmp	r1, #9
			width = pad = 0;
 9b2:	f04f 0500 	mov.w	r5, #0
			for ( ; *format >= '0' && *format <= '9'; ++format) {
 9b6:	d80a      	bhi.n	9ce <__text_size+0x52>
 9b8:	f814 0f01 	ldrb.w	r0, [r4, #1]!
				width *= 10;
 9bc:	eb05 0585 	add.w	r5, r5, r5, lsl #2
				width += *format - '0';
 9c0:	eb03 0545 	add.w	r5, r3, r5, lsl #1
			for ( ; *format >= '0' && *format <= '9'; ++format) {
 9c4:	f1a0 0330 	sub.w	r3, r0, #48	@ 0x30
 9c8:	b2d9      	uxtb	r1, r3
 9ca:	2909      	cmp	r1, #9
 9cc:	d9f4      	bls.n	9b8 <__text_size+0x3c>
			if( *format == 's' ) {
 9ce:	3858      	subs	r0, #88	@ 0x58
 9d0:	2820      	cmp	r0, #32
 9d2:	d8cc      	bhi.n	96e <print.constprop.0+0x1e>
 9d4:	a301      	add	r3, pc, #4	@ (adr r3, 9dc <__text_size+0x60>)
 9d6:	f853 f020 	ldr.w	pc, [r3, r0, lsl #2]
 9da:	bf00      	nop
 9dc:	00000b43 	.word	0x00000b43
 9e0:	0000096f 	.word	0x0000096f
 9e4:	0000096f 	.word	0x0000096f
 9e8:	0000096f 	.word	0x0000096f
 9ec:	0000096f 	.word	0x0000096f
 9f0:	0000096f 	.word	0x0000096f
 9f4:	0000096f 	.word	0x0000096f
 9f8:	0000096f 	.word	0x0000096f
 9fc:	0000096f 	.word	0x0000096f
 a00:	0000096f 	.word	0x0000096f
 a04:	0000096f 	.word	0x0000096f
 a08:	00000b1b 	.word	0x00000b1b
 a0c:	00000b13 	.word	0x00000b13
 a10:	0000096f 	.word	0x0000096f
 a14:	0000096f 	.word	0x0000096f
 a18:	0000096f 	.word	0x0000096f
 a1c:	0000096f 	.word	0x0000096f
 a20:	0000096f 	.word	0x0000096f
 a24:	0000096f 	.word	0x0000096f
 a28:	0000096f 	.word	0x0000096f
 a2c:	0000096f 	.word	0x0000096f
 a30:	0000096f 	.word	0x0000096f
 a34:	0000096f 	.word	0x0000096f
 a38:	0000096f 	.word	0x0000096f
 a3c:	0000096f 	.word	0x0000096f
 a40:	0000096f 	.word	0x0000096f
 a44:	0000096f 	.word	0x0000096f
 a48:	00000aa1 	.word	0x00000aa1
 a4c:	0000096f 	.word	0x0000096f
 a50:	00000a89 	.word	0x00000a89
 a54:	0000096f 	.word	0x0000096f
 a58:	0000096f 	.word	0x0000096f
 a5c:	00000a6f 	.word	0x00000a6f
			++format;
 a60:	4625      	mov	r5, r4
 a62:	e780      	b.n	966 <print.constprop.0+0x16>
	register int pc = 0;
 a64:	4606      	mov	r6, r0
		}
	}
	if (out) **out = '\0';
	va_end( args );
	return pc;
}
 a66:	4630      	mov	r0, r6
 a68:	b003      	add	sp, #12
 a6a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				pc += printi (out, va_arg( args, int ), 16, 0, width, pad, 'a');
 a6e:	9200      	str	r2, [sp, #0]
 a70:	462b      	mov	r3, r5
 a72:	2200      	movs	r2, #0
 a74:	4639      	mov	r1, r7
 a76:	2061      	movs	r0, #97	@ 0x61
				pc += printi (out, va_arg( args, int ), 16, 0, width, pad, 'A');
 a78:	9001      	str	r0, [sp, #4]
 a7a:	6808      	ldr	r0, [r1, #0]
 a7c:	2110      	movs	r1, #16
 a7e:	f7ff fe81 	bl	784 <printi.constprop.0>
 a82:	3704      	adds	r7, #4
 a84:	4406      	add	r6, r0
				continue;
 a86:	e772      	b.n	96e <print.constprop.0+0x1e>
				pc += printi (out, va_arg( args, int ), 10, 0, width, pad, 'a');
 a88:	9200      	str	r2, [sp, #0]
 a8a:	462b      	mov	r3, r5
 a8c:	2200      	movs	r2, #0
 a8e:	2061      	movs	r0, #97	@ 0x61
 a90:	9001      	str	r0, [sp, #4]
 a92:	6838      	ldr	r0, [r7, #0]
 a94:	210a      	movs	r1, #10
 a96:	f7ff fe75 	bl	784 <printi.constprop.0>
 a9a:	3704      	adds	r7, #4
 a9c:	4406      	add	r6, r0
				continue;
 a9e:	e766      	b.n	96e <print.constprop.0+0x1e>
				register char *s = (char *)va_arg( args, int );
 aa0:	683b      	ldr	r3, [r7, #0]
 aa2:	3704      	adds	r7, #4
				pc += prints (out, s?s:"(null)", width, pad);
 aa4:	2b00      	cmp	r3, #0
 aa6:	d055      	beq.n	b54 <__text_size+0x1d8>
	if (width > 0) {
 aa8:	2d00      	cmp	r5, #0
				register char *s = (char *)va_arg( args, int );
 aaa:	4698      	mov	r8, r3
	for ( ; *string ; ++string) {
 aac:	7818      	ldrb	r0, [r3, #0]
	if (!(pad & PAD_RIGHT)) {
 aae:	f002 0201 	and.w	r2, r2, #1
	if (width > 0) {
 ab2:	f340 809f 	ble.w	bf4 <__text_size+0x278>
		for (ptr = string; *ptr; ++ptr) ++len;
 ab6:	2800      	cmp	r0, #0
 ab8:	d056      	beq.n	b68 <__text_size+0x1ec>
 aba:	4643      	mov	r3, r8
 abc:	469e      	mov	lr, r3
 abe:	f813 1f01 	ldrb.w	r1, [r3, #1]!
 ac2:	2900      	cmp	r1, #0
 ac4:	d1fa      	bne.n	abc <__text_size+0x140>
 ac6:	f1c8 0b01 	rsb	fp, r8, #1
 aca:	44de      	add	lr, fp
		if (len >= width) width = 0;
 acc:	45ae      	cmp	lr, r5
 ace:	db49      	blt.n	b64 <__text_size+0x1e8>
		if (pad & PAD_ZERO) padchar = '0';
 ad0:	f1bc 0f00 	cmp.w	ip, #0
 ad4:	f040 8093 	bne.w	bfe <__text_size+0x282>
	register int pc = 0, padchar = ' ';
 ad8:	f04f 0a20 	mov.w	sl, #32
	for ( ; *string ; ++string) {
 adc:	2500      	movs	r5, #0
 ade:	46a9      	mov	r9, r5
    hal_uarte_char_write(c);
 ae0:	f000 f8e6 	bl	cb0 <hal_uarte_char_write>
	for ( ; *string ; ++string) {
 ae4:	4643      	mov	r3, r8
 ae6:	f818 0f01 	ldrb.w	r0, [r8, #1]!
 aea:	2800      	cmp	r0, #0
 aec:	d1f8      	bne.n	ae0 <__text_size+0x164>
 aee:	44ab      	add	fp, r5
	for ( ; width > 0; --width) {
 af0:	f1b9 0f00 	cmp.w	r9, #0
 af4:	eb03 050b 	add.w	r5, r3, fp
 af8:	dd21      	ble.n	b3e <__text_size+0x1c2>
    hal_uarte_char_write(c);
 afa:	46c8      	mov	r8, r9
 afc:	fa5f fa8a 	uxtb.w	sl, sl
 b00:	4650      	mov	r0, sl
 b02:	f000 f8d5 	bl	cb0 <hal_uarte_char_write>
	for ( ; width > 0; --width) {
 b06:	f1b8 0801 	subs.w	r8, r8, #1
 b0a:	d1f9      	bne.n	b00 <__text_size+0x184>
				pc += prints (out, s?s:"(null)", width, pad);
 b0c:	44a9      	add	r9, r5
 b0e:	444e      	add	r6, r9
				continue;
 b10:	e72d      	b.n	96e <print.constprop.0+0x1e>
				pc += printi (out, va_arg( args, int ), 10, 1, width, pad, 'a');
 b12:	9200      	str	r2, [sp, #0]
 b14:	462b      	mov	r3, r5
 b16:	2201      	movs	r2, #1
 b18:	e7b9      	b.n	a8e <__text_size+0x112>
	if (width > 0) {
 b1a:	2d00      	cmp	r5, #0
				scr[0] = (char)va_arg( args, int );
 b1c:	f897 a000 	ldrb.w	sl, [r7]
	if (!(pad & PAD_RIGHT)) {
 b20:	f002 0201 	and.w	r2, r2, #1
				scr[0] = (char)va_arg( args, int );
 b24:	f107 0704 	add.w	r7, r7, #4
	if (width > 0) {
 b28:	dd37      	ble.n	b9a <__text_size+0x21e>
		for (ptr = string; *ptr; ++ptr) ++len;
 b2a:	f1ba 0f00 	cmp.w	sl, #0
 b2e:	f000 8084 	beq.w	c3a <__text_size+0x2be>
		if (len >= width) width = 0;
 b32:	2d01      	cmp	r5, #1
 b34:	d137      	bne.n	ba6 <__text_size+0x22a>
    hal_uarte_char_write(c);
 b36:	4650      	mov	r0, sl
 b38:	f000 f8ba 	bl	cb0 <hal_uarte_char_write>
	register int pc = 0, padchar = ' ';
 b3c:	2501      	movs	r5, #1
				pc += prints (out, scr, width, pad);
 b3e:	442e      	add	r6, r5
 b40:	e715      	b.n	96e <print.constprop.0+0x1e>
				pc += printi (out, va_arg( args, int ), 16, 0, width, pad, 'A');
 b42:	9200      	str	r2, [sp, #0]
 b44:	462b      	mov	r3, r5
 b46:	2200      	movs	r2, #0
 b48:	4639      	mov	r1, r7
 b4a:	2041      	movs	r0, #65	@ 0x41
 b4c:	e794      	b.n	a78 <__text_size+0xfc>
			while (*format == '0') {
 b4e:	f04f 0c00 	mov.w	ip, #0
 b52:	e72a      	b.n	9aa <__text_size+0x2e>
	if (width > 0) {
 b54:	2d00      	cmp	r5, #0
 b56:	dd43      	ble.n	be0 <__text_size+0x264>
	if (!(pad & PAD_RIGHT)) {
 b58:	2028      	movs	r0, #40	@ 0x28
				pc += prints (out, s?s:"(null)", width, pad);
 b5a:	f8df 8100 	ldr.w	r8, [pc, #256]	@ c5c <__text_size+0x2e0>
	if (!(pad & PAD_RIGHT)) {
 b5e:	f002 0201 	and.w	r2, r2, #1
 b62:	e7aa      	b.n	aba <__text_size+0x13e>
		else width -= len;
 b64:	eba5 050e 	sub.w	r5, r5, lr
		if (pad & PAD_ZERO) padchar = '0';
 b68:	f1bc 0f00 	cmp.w	ip, #0
 b6c:	d14a      	bne.n	c04 <__text_size+0x288>
 b6e:	f04f 0b20 	mov.w	fp, #32
	register int pc = 0, padchar = ' ';
 b72:	46da      	mov	sl, fp
	if (!(pad & PAD_RIGHT)) {
 b74:	46a9      	mov	r9, r5
 b76:	b11a      	cbz	r2, b80 <__text_size+0x204>
	for ( ; *string ; ++string) {
 b78:	2800      	cmp	r0, #0
 b7a:	d068      	beq.n	c4e <__text_size+0x2d2>
 b7c:	2500      	movs	r5, #0
 b7e:	e009      	b.n	b94 <__text_size+0x218>
    hal_uarte_char_write(c);
 b80:	4658      	mov	r0, fp
 b82:	f000 f895 	bl	cb0 <hal_uarte_char_write>
		for ( ; width > 0; --width) {
 b86:	f1b9 0901 	subs.w	r9, r9, #1
 b8a:	d1f9      	bne.n	b80 <__text_size+0x204>
	for ( ; *string ; ++string) {
 b8c:	f898 0000 	ldrb.w	r0, [r8]
 b90:	2800      	cmp	r0, #0
 b92:	d0d4      	beq.n	b3e <__text_size+0x1c2>
 b94:	f1c8 0b01 	rsb	fp, r8, #1
 b98:	e7a2      	b.n	ae0 <__text_size+0x164>
	if (!(pad & PAD_RIGHT)) {
 b9a:	b9ea      	cbnz	r2, bd8 <__text_size+0x25c>
	for ( ; *string ; ++string) {
 b9c:	f1ba 0f00 	cmp.w	sl, #0
 ba0:	f43f aee5 	beq.w	96e <print.constprop.0+0x1e>
 ba4:	e7c7      	b.n	b36 <__text_size+0x1ba>
 ba6:	3d01      	subs	r5, #1
		if (pad & PAD_ZERO) padchar = '0';
 ba8:	f1bc 0f00 	cmp.w	ip, #0
 bac:	d12e      	bne.n	c0c <__text_size+0x290>
	if (!(pad & PAD_RIGHT)) {
 bae:	f04f 0920 	mov.w	r9, #32
 bb2:	b37a      	cbz	r2, c14 <__text_size+0x298>
    hal_uarte_char_write(c);
 bb4:	4650      	mov	r0, sl
 bb6:	f000 f87b 	bl	cb0 <hal_uarte_char_write>
		++pc;
 bba:	f04f 0a01 	mov.w	sl, #1
    hal_uarte_char_write(c);
 bbe:	46a8      	mov	r8, r5
 bc0:	fa5f f989 	uxtb.w	r9, r9
 bc4:	4648      	mov	r0, r9
 bc6:	f000 f873 	bl	cb0 <hal_uarte_char_write>
	for ( ; width > 0; --width) {
 bca:	f1b8 0801 	subs.w	r8, r8, #1
 bce:	d1f9      	bne.n	bc4 <__text_size+0x248>
				pc += prints (out, scr, width, pad);
 bd0:	eb05 030a 	add.w	r3, r5, sl
 bd4:	441e      	add	r6, r3
				continue;
 bd6:	e6ca      	b.n	96e <print.constprop.0+0x1e>
	for ( ; *string ; ++string) {
 bd8:	f1ba 0f00 	cmp.w	sl, #0
 bdc:	d1ab      	bne.n	b36 <__text_size+0x1ba>
 bde:	e6c6      	b.n	96e <print.constprop.0+0x1e>
	if (width > 0) {
 be0:	2028      	movs	r0, #40	@ 0x28
				pc += prints (out, s?s:"(null)", width, pad);
 be2:	f8df 8078 	ldr.w	r8, [pc, #120]	@ c5c <__text_size+0x2e0>
	for ( ; *string ; ++string) {
 be6:	46a9      	mov	r9, r5
 be8:	f04f 0a20 	mov.w	sl, #32
 bec:	2500      	movs	r5, #0
 bee:	f1c8 0b01 	rsb	fp, r8, #1
 bf2:	e775      	b.n	ae0 <__text_size+0x164>
	if (!(pad & PAD_RIGHT)) {
 bf4:	b9f2      	cbnz	r2, c34 <__text_size+0x2b8>
	for ( ; *string ; ++string) {
 bf6:	2800      	cmp	r0, #0
 bf8:	f43f aeb9 	beq.w	96e <print.constprop.0+0x1e>
 bfc:	e7f3      	b.n	be6 <__text_size+0x26a>
		if (pad & PAD_ZERO) padchar = '0';
 bfe:	f04f 0a30 	mov.w	sl, #48	@ 0x30
 c02:	e76b      	b.n	adc <__text_size+0x160>
 c04:	f04f 0b30 	mov.w	fp, #48	@ 0x30
 c08:	46da      	mov	sl, fp
 c0a:	e7b3      	b.n	b74 <__text_size+0x1f8>
	if (!(pad & PAD_RIGHT)) {
 c0c:	f04f 0930 	mov.w	r9, #48	@ 0x30
 c10:	2a00      	cmp	r2, #0
 c12:	d1cf      	bne.n	bb4 <__text_size+0x238>
 c14:	46a8      	mov	r8, r5
    hal_uarte_char_write(c);
 c16:	4648      	mov	r0, r9
 c18:	f000 f84a 	bl	cb0 <hal_uarte_char_write>
		for ( ; width > 0; --width) {
 c1c:	f1b8 0801 	subs.w	r8, r8, #1
 c20:	d1f9      	bne.n	c16 <__text_size+0x29a>
	for ( ; *string ; ++string) {
 c22:	f1ba 0f00 	cmp.w	sl, #0
 c26:	d08a      	beq.n	b3e <__text_size+0x1c2>
    hal_uarte_char_write(c);
 c28:	4650      	mov	r0, sl
		++pc;
 c2a:	3501      	adds	r5, #1
    hal_uarte_char_write(c);
 c2c:	f000 f840 	bl	cb0 <hal_uarte_char_write>
				pc += prints (out, scr, width, pad);
 c30:	442e      	add	r6, r5
 c32:	e69c      	b.n	96e <print.constprop.0+0x1e>
	for ( ; *string ; ++string) {
 c34:	2800      	cmp	r0, #0
 c36:	d1d6      	bne.n	be6 <__text_size+0x26a>
 c38:	e699      	b.n	96e <print.constprop.0+0x1e>
		if (pad & PAD_ZERO) padchar = '0';
 c3a:	f1bc 0f00 	cmp.w	ip, #0
 c3e:	d008      	beq.n	c52 <__text_size+0x2d6>
	if (!(pad & PAD_RIGHT)) {
 c40:	f04f 0930 	mov.w	r9, #48	@ 0x30
 c44:	2a00      	cmp	r2, #0
 c46:	d0e5      	beq.n	c14 <__text_size+0x298>
	register int pc = 0, padchar = ' ';
 c48:	f04f 0a00 	mov.w	sl, #0
 c4c:	e7b7      	b.n	bbe <__text_size+0x242>
	for ( ; *string ; ++string) {
 c4e:	4605      	mov	r5, r0
 c50:	e753      	b.n	afa <__text_size+0x17e>
	if (!(pad & PAD_RIGHT)) {
 c52:	f04f 0920 	mov.w	r9, #32
 c56:	2a00      	cmp	r2, #0
 c58:	d0dc      	beq.n	c14 <__text_size+0x298>
 c5a:	e7f5      	b.n	c48 <__text_size+0x2cc>
 c5c:	00000488 	.word	0x00000488

00000c60 <printf>:



int printf(const char *format, ...)
{
 c60:	b40f      	push	{r0, r1, r2, r3}
 c62:	b500      	push	{lr}
 c64:	b083      	sub	sp, #12
 c66:	a904      	add	r1, sp, #16
 c68:	f851 0b04 	ldr.w	r0, [r1], #4
        va_list args;

        va_start( args, format );
 c6c:	9101      	str	r1, [sp, #4]
        return print( 0, format, args );
 c6e:	f7ff fe6f 	bl	950 <print.constprop.0>
}
 c72:	b003      	add	sp, #12
 c74:	f85d eb04 	ldr.w	lr, [sp], #4
 c78:	b004      	add	sp, #16
 c7a:	4770      	bx	lr

00000c7c <hal_uarte_init>:


static bool m_initialized = false;

void hal_uarte_init(void)
{
 c7c:	b430      	push	{r4, r5}
  NRF_UARTE_Type * uarte_instance = (NRF_UARTE_Type *)CONFIG_HW_UARTE_INSTANCE;
  
  uarte_instance->BAUDRATE = UARTE_BAUDRATE_BAUDRATE_Baud1M;
  uarte_instance->PSEL.TXD = 4<<0 | 1<<5;//UART_TX_PIN;
 c7e:	2124      	movs	r1, #36	@ 0x24
  uarte_instance->BAUDRATE = UARTE_BAUDRATE_BAUDRATE_Baud1M;
 c80:	f04f 5580 	mov.w	r5, #268435456	@ 0x10000000
  uarte_instance->PSEL.RXD = 5<<0 | 1<<5;//UART_TX_PIN;
/*  uarte_instance->BAUDRATE = UARTE_BAUDRATE_BAUDRATE_Baud921600;*/
  uint32_t hwfc   = (UARTE_CONFIG_HWFC_Enabled << UARTE_CONFIG_HWFC_Pos);
  uint32_t parity = (UARTE_CONFIG_PARITY_Excluded << UARTE_CONFIG_PARITY_Pos);
  uarte_instance->CONFIG = (uint32_t)hwfc | (uint32_t)parity;
 c84:	2201      	movs	r2, #1
  uarte_instance->PSEL.RXD = 5<<0 | 1<<5;//UART_TX_PIN;
 c86:	2425      	movs	r4, #37	@ 0x25
  uarte_instance->ENABLE = (UARTE_ENABLE_ENABLE_Enabled << UARTE_ENABLE_ENABLE_Pos);
 c88:	2008      	movs	r0, #8
  uarte_instance->BAUDRATE = UARTE_BAUDRATE_BAUDRATE_Baud1M;
 c8a:	4b07      	ldr	r3, [pc, #28]	@ (ca8 <hal_uarte_init+0x2c>)
 c8c:	f8c3 5524 	str.w	r5, [r3, #1316]	@ 0x524
  uarte_instance->PSEL.TXD = 4<<0 | 1<<5;//UART_TX_PIN;
 c90:	f8c3 1604 	str.w	r1, [r3, #1540]	@ 0x604

  
  m_initialized = true;
 c94:	4905      	ldr	r1, [pc, #20]	@ (cac <hal_uarte_init+0x30>)
  uarte_instance->PSEL.RXD = 5<<0 | 1<<5;//UART_TX_PIN;
 c96:	f8c3 460c 	str.w	r4, [r3, #1548]	@ 0x60c
  uarte_instance->CONFIG = (uint32_t)hwfc | (uint32_t)parity;
 c9a:	f8c3 256c 	str.w	r2, [r3, #1388]	@ 0x56c
}
 c9e:	bc30      	pop	{r4, r5}
  uarte_instance->ENABLE = (UARTE_ENABLE_ENABLE_Enabled << UARTE_ENABLE_ENABLE_Pos);
 ca0:	f8c3 0500 	str.w	r0, [r3, #1280]	@ 0x500
  m_initialized = true;
 ca4:	700a      	strb	r2, [r1, #0]
}
 ca6:	4770      	bx	lr
 ca8:	500c6000 	.word	0x500c6000
 cac:	20000020 	.word	0x20000020

00000cb0 <hal_uarte_char_write>:

uint32_t hal_uarte_char_write(uint8_t ch) {
    if (!m_initialized) {
 cb0:	4b17      	ldr	r3, [pc, #92]	@ (d10 <hal_uarte_char_write+0x60>)
uint32_t hal_uarte_char_write(uint8_t ch) {
 cb2:	b430      	push	{r4, r5}
    if (!m_initialized) {
 cb4:	781a      	ldrb	r2, [r3, #0]
 cb6:	b98a      	cbnz	r2, cdc <hal_uarte_char_write+0x2c>
  uarte_instance->BAUDRATE = UARTE_BAUDRATE_BAUDRATE_Baud1M;
 cb8:	f04f 5580 	mov.w	r5, #268435456	@ 0x10000000
  uarte_instance->PSEL.TXD = 4<<0 | 1<<5;//UART_TX_PIN;
 cbc:	2424      	movs	r4, #36	@ 0x24
  uarte_instance->BAUDRATE = UARTE_BAUDRATE_BAUDRATE_Baud1M;
 cbe:	4a15      	ldr	r2, [pc, #84]	@ (d14 <hal_uarte_char_write+0x64>)
  uarte_instance->CONFIG = (uint32_t)hwfc | (uint32_t)parity;
 cc0:	2101      	movs	r1, #1
  uarte_instance->BAUDRATE = UARTE_BAUDRATE_BAUDRATE_Baud1M;
 cc2:	f8c2 5524 	str.w	r5, [r2, #1316]	@ 0x524
  uarte_instance->PSEL.TXD = 4<<0 | 1<<5;//UART_TX_PIN;
 cc6:	f8c2 4604 	str.w	r4, [r2, #1540]	@ 0x604
  uarte_instance->PSEL.RXD = 5<<0 | 1<<5;//UART_TX_PIN;
 cca:	2525      	movs	r5, #37	@ 0x25
  uarte_instance->ENABLE = (UARTE_ENABLE_ENABLE_Enabled << UARTE_ENABLE_ENABLE_Pos);
 ccc:	2408      	movs	r4, #8
  uarte_instance->PSEL.RXD = 5<<0 | 1<<5;//UART_TX_PIN;
 cce:	f8c2 560c 	str.w	r5, [r2, #1548]	@ 0x60c
  uarte_instance->CONFIG = (uint32_t)hwfc | (uint32_t)parity;
 cd2:	f8c2 156c 	str.w	r1, [r2, #1388]	@ 0x56c
  uarte_instance->ENABLE = (UARTE_ENABLE_ENABLE_Enabled << UARTE_ENABLE_ENABLE_Pos);
 cd6:	f8c2 4500 	str.w	r4, [r2, #1280]	@ 0x500
  m_initialized = true;
 cda:	7019      	strb	r1, [r3, #0]


    m_tx_buf[0] = ch;

    uarte_instance->DMA.TX.PTR = (uint32_t)((uint8_t *)m_tx_buf);
    uarte_instance->DMA.TX.MAXCNT = (uint32_t)sizeof(m_tx_buf);
 cdc:	2101      	movs	r1, #1
    uarte_instance->ERRORSRC = 0;
 cde:	2500      	movs	r5, #0
 ce0:	4a0c      	ldr	r2, [pc, #48]	@ (d14 <hal_uarte_char_write+0x64>)
    uarte_instance->DMA.TX.PTR = (uint32_t)((uint8_t *)m_tx_buf);
 ce2:	4c0d      	ldr	r4, [pc, #52]	@ (d18 <hal_uarte_char_write+0x68>)
    uarte_instance->ERRORSRC = 0;
 ce4:	f8c2 5480 	str.w	r5, [r2, #1152]	@ 0x480
    m_tx_buf[0] = ch;
 ce8:	7118      	strb	r0, [r3, #4]
    uarte_instance->DMA.TX.PTR = (uint32_t)((uint8_t *)m_tx_buf);
 cea:	f8c2 473c 	str.w	r4, [r2, #1852]	@ 0x73c
    uarte_instance->DMA.TX.MAXCNT = (uint32_t)sizeof(m_tx_buf);
 cee:	f8c2 1740 	str.w	r1, [r2, #1856]	@ 0x740
    uarte_instance->TASKS_DMA.TX.START = 1;
 cf2:	6511      	str	r1, [r2, #80]	@ 0x50


    while((0 == uarte_instance->EVENTS_TXDRDY)) ;
 cf4:	f8d2 310c 	ldr.w	r3, [r2, #268]	@ 0x10c
 cf8:	2b00      	cmp	r3, #0
 cfa:	d0fb      	beq.n	cf4 <hal_uarte_char_write+0x44>

    uarte_instance->EVENTS_TXDRDY  = 0;
    uarte_instance->TASKS_DMA.TX.STOP  = 1;

    return uarte_instance->ERRORSRC;
}
 cfc:	bc30      	pop	{r4, r5}
    uarte_instance->EVENTS_TXDRDY  = 0;
 cfe:	2100      	movs	r1, #0
    uarte_instance->TASKS_DMA.TX.STOP  = 1;
 d00:	2301      	movs	r3, #1
    uarte_instance->EVENTS_TXDRDY  = 0;
 d02:	f8c2 110c 	str.w	r1, [r2, #268]	@ 0x10c
    uarte_instance->TASKS_DMA.TX.STOP  = 1;
 d06:	6553      	str	r3, [r2, #84]	@ 0x54
    return uarte_instance->ERRORSRC;
 d08:	f8d2 0480 	ldr.w	r0, [r2, #1152]	@ 0x480
}
 d0c:	4770      	bx	lr
 d0e:	bf00      	nop
 d10:	20000020 	.word	0x20000020
 d14:	500c6000 	.word	0x500c6000
 d18:	20000024 	.word	0x20000024

00000d1c <hal_uarte_char_read>:

uint32_t hal_uarte_char_read(uint8_t * ch) {


}
 d1c:	4770      	bx	lr
 d1e:	bf00      	nop

00000d20 <Reset_Handler>:
 * All addresses must be aligned to 4 bytes boundary.
 */
#ifndef __STARTUP_SKIP_ETEXT

/* Load .data */
    ldr r1, =__data_start
 d20:	4919      	ldr	r1, [pc, #100]	@ (d88 <clear_bss_done+0x8>)
    ldr r2, =__data_end
 d22:	4a1a      	ldr	r2, [pc, #104]	@ (d8c <clear_bss_done+0xc>)
    ldr r3, =__data_load_start
 d24:	4b1a      	ldr	r3, [pc, #104]	@ (d90 <clear_bss_done+0x10>)
    bl copy_region
 d26:	f000 f810 	bl	d4a <copy_region>

/* Load .sdata */
    ldr r1, =__sdata_start
 d2a:	491a      	ldr	r1, [pc, #104]	@ (d94 <clear_bss_done+0x14>)
    ldr r2, =__sdata_end
 d2c:	4a1a      	ldr	r2, [pc, #104]	@ (d98 <clear_bss_done+0x18>)
    ldr r3, =__sdata_load_start
 d2e:	4b1b      	ldr	r3, [pc, #108]	@ (d9c <clear_bss_done+0x1c>)
    bl copy_region
 d30:	f000 f80b 	bl	d4a <copy_region>

/* Load .tdata */
    ldr r1, =__tdata_start
 d34:	491a      	ldr	r1, [pc, #104]	@ (da0 <clear_bss_done+0x20>)
    ldr r2, =__tdata_end
 d36:	4a1b      	ldr	r2, [pc, #108]	@ (da4 <clear_bss_done+0x24>)
    ldr r3, =__tdata_load_start
 d38:	4b1b      	ldr	r3, [pc, #108]	@ (da8 <clear_bss_done+0x28>)
    bl copy_region
 d3a:	f000 f806 	bl	d4a <copy_region>

/* Load .fast */
    ldr r1, =__fast_start
 d3e:	491b      	ldr	r1, [pc, #108]	@ (dac <clear_bss_done+0x2c>)
    ldr r2, =__fast_end
 d40:	4a1b      	ldr	r2, [pc, #108]	@ (db0 <clear_bss_done+0x30>)
    ldr r3, =__fast_load_start
 d42:	4b1c      	ldr	r3, [pc, #112]	@ (db4 <clear_bss_done+0x34>)
    bl copy_region
 d44:	f000 f801 	bl	d4a <copy_region>

    b copy_etext_done
 d48:	e006      	b.n	d58 <copy_etext_done>

00000d4a <copy_region>:

/* Method that loads data from nvm to ram */
copy_region:
    subs r2, r2, r1
 d4a:	1a52      	subs	r2, r2, r1
    ble L_copy_region_done
 d4c:	dd03      	ble.n	d56 <L_copy_region_done>

00000d4e <L_copy_region>:

L_copy_region:
    subs r2, r2, #4
 d4e:	3a04      	subs	r2, #4
    ldr r0, [r3,r2]
 d50:	5898      	ldr	r0, [r3, r2]
    str r0, [r1,r2]
 d52:	5088      	str	r0, [r1, r2]
    bgt L_copy_region
 d54:	dcfb      	bgt.n	d4e <L_copy_region>

00000d56 <L_copy_region_done>:

L_copy_region_done:

    bx lr
 d56:	4770      	bx	lr

00000d58 <copy_etext_done>:
 *    __bss_end__: end of the BSS section.
 *
 * All addresses must be aligned to 4 bytes boundary.
 */
#ifdef __STARTUP_CLEAR_BSS
    ldr r1, =__bss_start__
 d58:	4917      	ldr	r1, [pc, #92]	@ (db8 <clear_bss_done+0x38>)
    ldr r2, =__bss_end__
 d5a:	4a18      	ldr	r2, [pc, #96]	@ (dbc <clear_bss_done+0x3c>)
    bl clear_region
 d5c:	f000 f809 	bl	d72 <clear_region>

    ldr r1, =__tbss_start__
 d60:	4917      	ldr	r1, [pc, #92]	@ (dc0 <clear_bss_done+0x40>)
    ldr r2, =__tbss_end__
 d62:	4a18      	ldr	r2, [pc, #96]	@ (dc4 <clear_bss_done+0x44>)
    bl clear_region
 d64:	f000 f805 	bl	d72 <clear_region>

    ldr r1, =__sbss_start__
 d68:	4917      	ldr	r1, [pc, #92]	@ (dc8 <clear_bss_done+0x48>)
    ldr r2, =__sbss_end__
 d6a:	4a18      	ldr	r2, [pc, #96]	@ (dcc <clear_bss_done+0x4c>)
    bl clear_region
 d6c:	f000 f801 	bl	d72 <clear_region>

    b clear_bss_done
 d70:	e006      	b.n	d80 <clear_bss_done>

00000d72 <clear_region>:

/* Method that clears default-0 registers */
clear_region:
    movs r0, 0
 d72:	2000      	movs	r0, #0

    subs r2, r2, r1
 d74:	1a52      	subs	r2, r2, r1
    ble .L_clear_region_done
 d76:	dd02      	ble.n	d7e <clear_region+0xc>

.L_clear_region:
    subs r2, r2, #4
 d78:	3a04      	subs	r2, #4
    str r0, [r1, r2]
 d7a:	5088      	str	r0, [r1, r2]
    bgt .L_clear_region
 d7c:	dcfc      	bgt.n	d78 <clear_region+0x6>

.L_clear_region_done:

    bx lr
 d7e:	4770      	bx	lr

00000d80 <clear_bss_done>:
clear_bss_done:

#endif /* __STARTUP_CLEAR_BSS */

/* Execute SystemInit function. */
    bl SystemInit
 d80:	f7ff fbec 	bl	55c <SystemInit>
 * If those libraries are not accessible, define __START as your entry point.
 */
#ifndef __START
#define __START _start
#endif
    bl __START
 d84:	f7ff fbca 	bl	51c <main>
    ldr r1, =__data_start
 d88:	20000000 	.word	0x20000000
    ldr r2, =__data_end
 d8c:	20000004 	.word	0x20000004
    ldr r3, =__data_load_start
 d90:	00000e54 	.word	0x00000e54
    ldr r1, =__sdata_start
 d94:	20000004 	.word	0x20000004
    ldr r2, =__sdata_end
 d98:	20000004 	.word	0x20000004
    ldr r3, =__sdata_load_start
 d9c:	00000e58 	.word	0x00000e58
    ldr r1, =__tdata_start
 da0:	20000004 	.word	0x20000004
    ldr r2, =__tdata_end
 da4:	20000004 	.word	0x20000004
    ldr r3, =__tdata_load_start
 da8:	00000e58 	.word	0x00000e58
    ldr r1, =__fast_start
 dac:	20000004 	.word	0x20000004
    ldr r2, =__fast_end
 db0:	20000004 	.word	0x20000004
    ldr r3, =__fast_load_start
 db4:	00000e58 	.word	0x00000e58
    ldr r1, =__bss_start__
 db8:	20000004 	.word	0x20000004
    ldr r2, =__bss_end__
 dbc:	20000028 	.word	0x20000028
    ldr r1, =__tbss_start__
 dc0:	20000028 	.word	0x20000028
    ldr r2, =__tbss_end__
 dc4:	20000028 	.word	0x20000028
    ldr r1, =__sbss_start__
 dc8:	20000028 	.word	0x20000028
    ldr r2, =__sbss_end__
 dcc:	20000028 	.word	0x20000028

00000dd0 <NMI_Handler>:
/* Dummy Exception Handlers (infinite loops which can be modified) */

    .weak   NMI_Handler
    .type   NMI_Handler, %function
NMI_Handler:
    b       .
 dd0:	e7fe      	b.n	dd0 <NMI_Handler>

00000dd2 <HardFault_Handler>:


    .weak   HardFault_Handler
    .type   HardFault_Handler, %function
HardFault_Handler:
    b       .
 dd2:	e7fe      	b.n	dd2 <HardFault_Handler>

00000dd4 <MemoryManagement_Handler>:


    .weak   MemoryManagement_Handler
    .type   MemoryManagement_Handler, %function
MemoryManagement_Handler:
    b       .
 dd4:	e7fe      	b.n	dd4 <MemoryManagement_Handler>

00000dd6 <BusFault_Handler>:


    .weak   BusFault_Handler
    .type   BusFault_Handler, %function
BusFault_Handler:
    b       .
 dd6:	e7fe      	b.n	dd6 <BusFault_Handler>

00000dd8 <UsageFault_Handler>:


    .weak   UsageFault_Handler
    .type   UsageFault_Handler, %function
UsageFault_Handler:
    b       .
 dd8:	e7fe      	b.n	dd8 <UsageFault_Handler>

00000dda <SecureFault_Handler>:


    .weak   SecureFault_Handler
    .type   SecureFault_Handler, %function
SecureFault_Handler:
    b       .
 dda:	e7fe      	b.n	dda <SecureFault_Handler>

00000ddc <SVC_Handler>:


    .weak   SVC_Handler
    .type   SVC_Handler, %function
SVC_Handler:
    b       .
 ddc:	e7fe      	b.n	ddc <SVC_Handler>

00000dde <DebugMon_Handler>:


    .weak   DebugMon_Handler
    .type   DebugMon_Handler, %function
DebugMon_Handler:
    b       .
 dde:	e7fe      	b.n	dde <DebugMon_Handler>

00000de0 <PendSV_Handler>:


    .weak   PendSV_Handler
    .type   PendSV_Handler, %function
PendSV_Handler:
    b       .
 de0:	e7fe      	b.n	de0 <PendSV_Handler>

00000de2 <SysTick_Handler>:


    .weak   SysTick_Handler
    .type   SysTick_Handler, %function
SysTick_Handler:
    b       .
 de2:	e7fe      	b.n	de2 <SysTick_Handler>

00000de4 <Default_Handler>:
/* IRQ Handlers */

    .globl  Default_Handler
    .type   Default_Handler, %function
Default_Handler:
    b       .
 de4:	e7fe      	b.n	de4 <Default_Handler>
 de6:	bf00      	nop

00000de8 <_init>:
 de8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 dea:	bf00      	nop
 dec:	bcf8      	pop	{r3, r4, r5, r6, r7}
 dee:	bc08      	pop	{r3}
 df0:	469e      	mov	lr, r3
 df2:	4770      	bx	lr

00000df4 <__frame_dummy_init_array_entry>:
 df4:	04fd 0000                                   ....

00000df8 <_fini>:
 df8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 dfa:	bf00      	nop
 dfc:	bcf8      	pop	{r3, r4, r5, r6, r7}
 dfe:	bc08      	pop	{r3}
 e00:	469e      	mov	lr, r3
 e02:	4770      	bx	lr

00000e04 <__do_global_dtors_aux_fini_array_entry>:
 e04:	04d5 0000                                   ....

00000e08 <__EH_FRAME_BEGIN__>:
 e08:	0000 0000                                   ....
